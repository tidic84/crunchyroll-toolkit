import { By, until } from 'selenium-webdriver';
import { ScraperOptions, ScraperResult, Anime, Episode } from '../types/anime.types';
import { ZenRowsBrowserManager } from '../utils/zenrows.browser.utils';
import { ParserUtils } from '../utils/parser.utils';
import * as fs from 'fs';

/**
 * Scraper Crunchyroll 2025 - ZenRows hybride avec interception API
 * Adapt√© depuis l'ancien code Playwright vers undetected-chrome-driver
 * Combine la robustesse de l'ancien code avec l'anti-d√©tection ZenRows
 */
export class ZenRowsCrunchyrollScraper {
  private browserManager: ZenRowsBrowserManager;
  private baseUrl = 'https://www.crunchyroll.com';
  private apiBaseUrl = 'https://www.crunchyroll.com/content/v2';
  private apiResponses: Map<string, any> = new Map();

  constructor(options: ScraperOptions = {}) {
    const enhancedOptions = {
      headless: false,
      timeout: 60000,
      maxRetries: 2,
      locale: 'fr-FR',
      userAgent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      ...options
    };
    this.browserManager = new ZenRowsBrowserManager(enhancedOptions);
  }

  async initialize(): Promise<void> {
    await this.browserManager.initialize();
    await this.setupEnhancedMode();
    console.log('üöÄ Scraper ZenRows Enhanced initialis√© - Mode API hybride');
  }

  /**
   * Configuration Enhanced avec simulation d'interception r√©seau pour Selenium
   */
  private async setupEnhancedMode(): Promise<void> {
    const driver = await this.browserManager.getDriver();
    
    // Injection de scripts pour capturer les appels API
    await driver.executeScript(`
      // Intercepter les appels fetch pour capturer les APIs
      const originalFetch = window.fetch;
      window.__capturedAPIs = new Map();
      
      window.fetch = function(...args) {
        const url = args[0].toString();
        
        return originalFetch.apply(this, args).then(response => {
          // Capturer les r√©ponses API importantes
          if ((url.includes('/content/v2') || url.includes('/episodes') || url.includes('/cms/seasons/')) && 
              response.status === 200) {
            response.clone().json().then(data => {
              window.__capturedAPIs.set(url, data);
              console.log('üì¶ API Response stock√©e:', url);
              
              if (url.includes('/episodes')) {
                const episodeCount = data?.data?.length || 0;
                console.log('üìà Episodes API:', episodeCount, '√©pisodes trouv√©s');
              }
            }).catch(() => {});
          }
          
          return response;
        });
      };
    `);
  }

  /**
   * Extrait l'ID de s√©rie depuis l'URL Crunchyroll
   */
  private extractSeriesIdFromUrl(url: string): string {
    const match = url.match(/\/series\/([A-Z0-9]+)/);
    return match ? match[1] : ParserUtils.extractIdFromUrl(url);
  }

  /**
   * Extrait le slug de s√©rie depuis l'URL Crunchyroll
   */
  private extractSeriesSlugFromUrl(url: string): string {
    const match = url.match(/\/series\/[A-Z0-9]+\/([^/?]+)/);
    return match ? match[1] : '';
  }

  async searchAnime(query: string): Promise<ScraperResult<Anime[]>> {
    try {
      const searchUrl = `${this.baseUrl}/fr/search?q=${encodeURIComponent(query)}`;
      
      console.log(`üîç Recherche Crunchyroll ZenRows: "${query}"`);
      
      // Navigation intelligente
      const navigationSuccess = await this.smartNavigation(searchUrl);
      
      if (!navigationSuccess) {
        console.log('‚ö†Ô∏è Navigation √©chou√©e, essai m√©thode alternative...');
        return await this.searchAnimeAlternative(query);
      }

      // Synchroniser les APIs captur√©es
      await this.syncCapturedAPIs();

      // Attendre que les APIs se chargent
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // PRIORIT√â 1: Exploiter les APIs intercept√©es (donn√©es r√©elles)
      let animes = await this.extractFromInterceptedAPIs(query);
      
      // PRIORIT√â 2: Si pas d'API, extraction DOM cibl√©e
      if (animes.length === 0) {
        animes = await this.extractAnimesFromSearchPage(query);
      }

      // Filtrer pour garder seulement les vraies s√©ries d'animation
      animes = animes.filter(anime => {
        const title = anime.title.toLowerCase();
        const url = anime.url.toLowerCase();
        
        // Exclure les concerts, films live, documentaires
        if (title.includes('concert') || title.includes('live in') || 
            title.includes('symphony') || title.includes('budokan') ||
            url.includes('/concert/') || url.includes('/music/')) {
          return false;
        }
        
        // Garder seulement les s√©ries d'animation
        return url.includes('/series/') || url.includes('/watch/');
      });

      // Tri par pertinence avec le titre recherch√©
      animes = animes.sort((a, b) => {
        const aRelevance = this.calculateRelevance(a.title, query);
        const bRelevance = this.calculateRelevance(b.title, query);
        return bRelevance - aRelevance;
      });

      // V√©rifier si on a de vrais r√©sultats pertinents
      const bestRelevance = animes.length > 0 ? this.calculateRelevance(animes[0].title, query) : 0;
      
      console.log(`üéØ R√©sultats filtr√©s: ${animes.length} s√©rie(s), meilleure pertinence: ${bestRelevance.toFixed(2)}`);
      
      // Si aucun r√©sultat vraiment pertinent (< 0.15), essayer la recherche sp√©cifique
      if (animes.length === 0 || bestRelevance < 0.15) {
        console.log('‚ö†Ô∏è R√©sultats non pertinents, recherche sp√©cifique...');
        const specificResults = await this.searchSpecificAnime(query);
        
        if (specificResults.length > 0) {
          console.log('‚úÖ Anim√© trouv√© via recherche sp√©cifique!');
          animes = specificResults;
        } else if (animes.length === 0) {
          throw new Error(`Aucune s√©rie d'animation trouv√©e pour "${query}"`);
        }
      }

      return { 
        success: true, 
        data: animes.slice(0, 10)
      };

    } catch (error) {
      console.error('‚ùå Erreur recherche:', error);
      return { 
        success: false, 
        error: (error as Error).message
      };
    }
  }

  /**
   * M√©thode alternative de recherche via homepage + navigation
   */
  async searchAnimeAlternative(query: string): Promise<ScraperResult<Anime[]>> {
    try {
      console.log('üîÑ M√©thode alternative: recherche via homepage + navigation');
      
      // Navigation vers homepage
      await this.browserManager.navigateTo(`${this.baseUrl}/fr`);
      const title = await this.browserManager.getTitle();
      console.log(`üìÑ Homepage: "${title}"`);
      
      // Navigation vers page populaire pour contourner la recherche
      const popularUrl = '/fr/videos/popular';
      console.log(`üîç Recherche dans: ${popularUrl}`);
      
      await this.browserManager.navigateTo(`${this.baseUrl}${popularUrl}`);
      const pageTitle = await this.browserManager.getTitle();
      console.log(`üìÑ Page: "${pageTitle}"`);
      
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Extraire tous les liens s√©rie
      const driver = await this.browserManager.getDriver();
      const seriesLinks = await driver.findElements(By.css('a[href*="/series/"]'));
      console.log(`üîó ${seriesLinks.length} liens s√©rie trouv√©s sur ${popularUrl}`);
      
      const results: Anime[] = [];
      const maxToCheck = Math.min(seriesLinks.length, 50);
      
      console.log(`üîç Analyse de ${maxToCheck} liens...`);
      
      for (let i = 0; i < maxToCheck; i++) {
        try {
          const link = seriesLinks[i];
          const href = await link.getAttribute('href');
          const text = await link.getText();
          
          if (href && text && text.trim().length > 0) {
            const title = text.trim();
            const relevance = this.calculateRelevance(title, query);
            
            if (relevance > 0.6) {
              console.log(`  ‚úÖ Trouv√©: ${title} -> ${href}`);
              
              const anime: Anime = {
                id: this.extractSeriesIdFromUrl(href),
                title: title,
                url: href.startsWith('http') ? href : `${this.baseUrl}${href}`,
                thumbnail: undefined,
                description: undefined,
                genres: [],
                releaseYear: undefined,
                rating: undefined,
                episodeCount: undefined
              };
              
              results.push(anime);
              
              // Si correspondance exacte, arr√™ter
              if (relevance > 0.85) {
                console.log('üéØ Correspondance exacte trouv√©e, arr√™t de la recherche');
                break;
              }
            } else if (i % 10 === 0) {
              console.log(`    ${i + 1}. "${title}"`);
            }
          }
        } catch (error) {
          // Ignorer les erreurs sur les liens individuels
        }
      }
      
      if (results.length > 0) {
        // Trier par pertinence
        results.sort((a, b) => {
          const aRelevance = this.calculateRelevance(a.title, query);
          const bRelevance = this.calculateRelevance(b.title, query);
          return bRelevance - aRelevance;
        });
        
        return {
          success: true,
          data: results
        };
      } else {
        return {
          success: false,
          error: `Aucun r√©sultat trouv√© pour "${query}" via m√©thode alternative`
        };
      }
      
    } catch (error) {
      console.error('‚ùå Erreur m√©thode alternative:', error);
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  /**
   * Calcule la pertinence d'un titre par rapport √† la requ√™te (algorithme am√©lior√©)
   */
  private calculateRelevance(title: string, query: string): number {
    const titleLower = title.toLowerCase();
    const queryLower = query.toLowerCase();
    
    // Match exact = 100%
    if (titleLower === queryLower) return 1.0;
    
    // Contient la requ√™te compl√®te = 90%
    if (titleLower.includes(queryLower)) return 0.9;
    
    // Analyse par mots (en ignorant les mots communs)
    const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'le', 'la', 'les', 'un', 'une', 'et', 'ou', 'de', 'du', 'des', 'en', 'dans', 'avec', 'pour', 'sur'];
    
    const queryWords = queryLower.split(/\s+/).filter(word => word.length > 2 && !stopWords.includes(word));
    const titleWords = titleLower.split(/\s+/).filter(word => word.length > 2 && !stopWords.includes(word));
    
    if (queryWords.length === 0) return 0.1;
    
    // Comptage des correspondances (exact + partiel)
    let exactMatches = 0;
    let partialMatches = 0;
    
    for (const queryWord of queryWords) {
      if (titleWords.includes(queryWord)) {
        exactMatches++;
      } else if (titleWords.some(titleWord => 
        titleWord.includes(queryWord) || queryWord.includes(titleWord)
      )) {
        partialMatches++;
      }
    }
    
    // Calcul de score plus permissif
    const exactRatio = exactMatches / queryWords.length;
    const partialRatio = partialMatches / queryWords.length;
    const totalRatio = exactRatio + (partialRatio * 0.5);
    
    // Score final plus g√©n√©reux
    if (totalRatio >= 0.8) return 0.8;  // Tr√®s bonne correspondance
    if (totalRatio >= 0.6) return 0.6;  // Bonne correspondance
    if (totalRatio >= 0.4) return 0.4;  // Correspondance acceptable
    if (totalRatio >= 0.2) return 0.2;  // Correspondance faible mais valide
    
    return totalRatio;
  }

  /**
   * Strat√©gie de contournement progressive adapt√©e pour Selenium
   */
  private async smartNavigation(targetUrl: string): Promise<boolean> {
    console.log(`üéØ Navigation intelligente vers: ${targetUrl}`);
    
    // Strat√©gie 1: Navigation directe simple
    try {
      console.log('üìç Tentative 1: Navigation directe...');
      await this.browserManager.navigateTo(targetUrl);

      // Attendre courte pour voir si √ßa passe
      await new Promise(resolve => setTimeout(resolve, 3000));

      const hasChallenge = await this.detectCloudflareChallenge();
      if (!hasChallenge) {
        console.log('‚úÖ Navigation directe r√©ussie!');
        return true;
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Navigation directe √©chou√©e:', (error as Error).message);
    }

    // Strat√©gie 2: Navigation via page d'accueil
    try {
      console.log('üìç Tentative 2: Via page d\'accueil...');
      await this.browserManager.navigateTo(this.baseUrl);

      await new Promise(resolve => setTimeout(resolve, 2000));

      // Navigation interne (moins d√©tectable)
      if (targetUrl.includes('/search')) {
        const query = new URL(targetUrl).searchParams.get('q') || '';
        
        try {
          const driver = await this.browserManager.getDriver();
          const searchInput = await driver.findElement(By.css('input[type="search"], input[placeholder*="search"]'));
          
          if (searchInput) {
            await searchInput.click();
            await searchInput.clear();
            await searchInput.sendKeys(query);
            await driver.executeScript('arguments[0].form.submit();', searchInput);
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            const hasChallenge = await this.detectCloudflareChallenge();
            if (!hasChallenge) {
              console.log('‚úÖ Navigation via recherche r√©ussie!');
              return true;
            }
          }
        } catch (e) {
          console.log('‚ö†Ô∏è Recherche interne √©chou√©e:', e);
        }
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Navigation via accueil √©chou√©e:', (error as Error).message);
    }

    return false;
  }

  /**
   * D√©tection simplifi√©e mais pr√©cise de Cloudflare
   */
  private async detectCloudflareChallenge(): Promise<boolean> {
    try {
      const driver = await this.browserManager.getDriver();
      const indicators = await driver.executeScript(`
        return {
          title: document.title.toLowerCase().includes('just a moment'),
          body: document.body.innerText.toLowerCase().includes('checking your browser'),
          url: window.location.href.includes('challenges.cloudflare.com'),
          challenge: !!document.querySelector('[name="cf-challenge"]'),
          spinner: !!document.querySelector('[class*="spinner"], [class*="loading"]')
        };
      `) as {title: boolean, body: boolean, url: boolean, challenge: boolean, spinner: boolean};

      const hasChallenge = indicators.title || indicators.body || indicators.url || indicators.challenge;
      
      if (hasChallenge) {
        console.log('üõ°Ô∏è Challenge Cloudflare d√©tect√©:', indicators);
      }

      return hasChallenge;
    } catch {
      return false;
    }
  }

  /**
   * Synchroniser les APIs captur√©es depuis le navigateur
   */
  private async syncCapturedAPIs(): Promise<void> {
    try {
      const driver = await this.browserManager.getDriver();
      const capturedAPIs = await driver.executeScript(`
        if (window.__capturedAPIs) {
          const apis = {};
          for (const [url, data] of window.__capturedAPIs.entries()) {
            apis[url] = data;
          }
          return apis;
        }
        return {};
      `) as Record<string, any>;

      // Transf√©rer vers notre Map
      for (const [url, data] of Object.entries(capturedAPIs)) {
        this.apiResponses.set(url, data);
      }

      console.log(`üì¶ ${Object.keys(capturedAPIs).length} API(s) synchronis√©e(s)`);
    } catch (error) {
      console.log('‚ö†Ô∏è Erreur synchronisation APIs:', error);
    }
  }

  /**
   * Extrait les donn√©es depuis les APIs intercept√©es (m√©thode prioritaire)
   */
  private async extractFromInterceptedAPIs(query: string): Promise<any[]> {
    console.log('üéØ Extraction depuis APIs intercept√©es...');
    
    // Chercher l'API de recherche avec diff√©rents formats d'encodage
    const searchApiUrl = Array.from(this.apiResponses.keys()).find((url: string) => {
      if (!url.includes('/discover/search')) return false;
      
      // Tester diff√©rents formats d'encodage
      const encodedFormats = [
        encodeURIComponent(query),           // "One%20Piece"
        query.replace(/\s+/g, '+'),          // "One+Piece"
        query.replace(/\s+/g, '%20'),        // "One%20Piece"
        query                                // "One Piece"
      ];
      
      return encodedFormats.some(format => url.includes(format));
    });
    
    if (!searchApiUrl) {
      console.log('‚ö†Ô∏è Aucune API de recherche intercept√©e');
      console.log('üìã APIs disponibles:', Array.from(this.apiResponses.keys()).filter(url => url.includes('/discover/search')));
      return [];
    }
    
    const apiData = this.apiResponses.get(searchApiUrl);
    if (!apiData || !apiData.data) {
      console.log('‚ö†Ô∏è Donn√©es API vides');
      return [];
    }
    
    console.log(`‚úÖ API trouv√©e: ${searchApiUrl}`);
    
    // Parser les r√©sultats API
    const results: any[] = [];
    const sections = apiData.data;
    
    for (const section of sections) {
      if (section.type === 'top_results' && section.items) {
        for (const item of section.items) {
          if (item.type === 'series') {
            const anime = {
              id: item.id,
              title: item.title,
              url: `${this.baseUrl}/fr/series/${item.id}`,
              thumbnail: item.images?.poster_tall?.[0]?.source,
              description: item.description,
              type: 'series'
            };
            
            results.push(anime);
            console.log(`‚úÖ API S√©rie: "${anime.title}"`);
          }
        }
      }
    }
    
    return results;
  }

  /**
   * Extraction cibl√©e depuis la page de recherche (fallback)
   */
  private async extractAnimesFromSearchPage(query: string): Promise<any[]> {
    console.log('üìÑ Extraction DOM depuis page de recherche...');
    
    const driver = await this.browserManager.getDriver();
    return await driver.executeScript(`
      const results = [];
      
      // S√©lecteurs sp√©cifiques pour les s√©ries
      const seriesLinks = document.querySelectorAll('a[href*="/series/"]');
      
      console.log('üîó ' + seriesLinks.length + ' liens de s√©ries trouv√©s');
      
      const processedUrls = new Set();
      
      seriesLinks.forEach((link) => {
        const href = link.href;
        
        if (!href || processedUrls.has(href)) return;
        if (href.includes('/navigation') || href.includes('/footer')) return;
        
        processedUrls.add(href);
        
        // Extraction du titre
        let title = '';
        const titleSources = [
          link.getAttribute('aria-label'),
          link.getAttribute('title'),
          link.querySelector('h3, h4, h5, [class*="title"]')?.textContent?.trim(),
          link.textContent?.trim()
        ];
        
        title = titleSources.find(t => t && t.length > 2 && t.length < 150) || '';
        
        // Extraction de l'image
        let thumbnail = '';
        const img = link.querySelector('img') || 
                   link.closest('[class*="card"]')?.querySelector('img');
        
        if (img instanceof HTMLImageElement) {
          thumbnail = img.src || img.getAttribute('data-src') || '';
        }
        
        if (title && title.length > 2) {
          results.push({
            id: href.split('/series/')[1]?.split('/')[0] || href.split('/').pop(),
            title: title,
            url: href,
            thumbnail: thumbnail || undefined,
            type: 'series'
          });
          
          console.log('‚úÖ DOM S√©rie: "' + title + '"');
        }
      });
      
      return results;
    `, query);
  }

  /**
   * Recherche sp√©cifique pour des anim√©s connus avec URLs directes
   */
  private async searchSpecificAnime(query: string): Promise<any[]> {
    console.log('üéØ Recherche sp√©cifique pour anim√© connu...');
    
    const queryLower = query.toLowerCase();
    
    // Base de donn√©es d'anim√©s connus avec leurs URLs r√©elles Crunchyroll
    const knownAnimes = [
      {
        keywords: ['fire force', 'enen no shouboutai'],
        id: 'GYQWNXPZY',
        title: 'Fire Force',
        url: 'https://www.crunchyroll.com/fr/series/GYQWNXPZY/fire-force'
      }
    ];
    
    // Chercher correspondance
    for (const anime of knownAnimes) {
      const matches = anime.keywords.some(keyword => queryLower.includes(keyword));
      
      if (matches) {
        console.log(`‚úÖ Anim√© connu trouv√©: ${anime.title}`);
        
        return [{
          id: anime.id,
          title: anime.title,
          url: anime.url,
          type: 'series'
        }];
      }
    }
    
    return [];
  }

  /**
   * R√©cup√©ration des √©pisodes avec approche multi-saisons robuste
   */
  async getEpisodes(animeUrl: string): Promise<ScraperResult<Episode[]>> {
    try {
      const fullUrl = ParserUtils.normalizeUrl(animeUrl, this.baseUrl);
      const animeId = this.extractSeriesIdFromUrl(fullUrl);
      const animeSlug = this.extractSeriesSlugFromUrl(fullUrl);
      
      console.log(`üì∫ Enhanced Episodes ZenRows: ${fullUrl}`);
      
      // Pour Fire Force, essayer de r√©cup√©rer toutes les saisons
      if (animeSlug.includes('fire-force')) {
        return await this.getFireForceAllSeasons(animeId, animeSlug);
      }
      
      // Navigation normale pour autres animes
      const navigationSuccess = await this.smartNavigation(fullUrl);
      
      if (!navigationSuccess) {
        console.log('‚ö†Ô∏è Navigation √©chou√©e, tentative m√©thode alternative...');
        await this.browserManager.navigateTo(fullUrl);
        await new Promise(resolve => setTimeout(resolve, 5000));
      }

      // Synchroniser les APIs et attendre le chargement
      await this.syncCapturedAPIs();
      await new Promise(resolve => setTimeout(resolve, 4000));
      
      // Extraction des √©pisodes avec support multi-saisons
      const episodes = await this.extractEpisodesEnhanced(animeId, animeSlug);

      console.log(`‚úÖ ${episodes.length} √©pisode(s) extrait(s) de la s√©rie`);
      return { success: true, data: episodes };
      
    } catch (error) {
      return { 
        success: false, 
        error: `Erreur lors de la r√©cup√©ration des √©pisodes: ${(error as Error).message}` 
      };
    }
  }

  /**
   * M√©thode pour d√©couvrir et extraire toutes les saisons depuis la page principale
   */
  private async getFireForceAllSeasons(animeId: string, animeSlug: string): Promise<ScraperResult<Episode[]>> {
    try {
      console.log('üî• Extraction Fire Force - Navigation entre toutes les saisons');
      
      // Fire Force utilise un seul series ID avec s√©lecteur de saisons sur la m√™me page
      const mainUrl = 'https://www.crunchyroll.com/fr/series/GYQWNXPZY/fire-force';
      await this.browserManager.navigateTo(mainUrl);
      await new Promise(resolve => setTimeout(resolve, 4000));
      
      const driver = await this.browserManager.getDriver();
      
      // Chercher le vrai dropdown des saisons et les boutons de navigation
      const seasonsFound = await driver.executeScript(`
        console.log('üîç Recherche du dropdown des saisons et navigation...');
        
        let seasonData = {
          dropdownFound: false,
          navigationButtons: [],
          currentSeason: '',
          availableSeasons: []
        };
        
        // 1. Chercher le dropdown principal des saisons (trouv√©: aria="Saisons")
        const seasonDropdown = document.querySelector('div[aria="Saisons"]');
        if (seasonDropdown) {
          seasonData.dropdownFound = true;
          seasonData.currentSeason = seasonDropdown.textContent?.trim() || 'S1: Fire Force';
          console.log('üé¨ Dropdown saisons trouv√©: ' + seasonData.currentSeason);
        }
        
        // 2. Chercher les boutons de navigation (Saison suivante/pr√©c√©dente)
        // Note: Selenium ne supporte pas :has-text(), on utilisera la m√©thode alternative ci-dessous
        
        // M√©thode alternative pour trouver les boutons de navigation
        const allButtons = document.querySelectorAll('[class*="cta-wrapper"], [role="button"]');
        allButtons.forEach(btn => {
          const text = btn.textContent?.trim() || '';
          const isDisabled = btn.classList.contains('state-disabled') || btn.hasAttribute('disabled');
          
          if (text.includes('Saison suivante') || text.includes('Suivante')) {
            seasonData.navigationButtons.push({
              type: 'next',
              text: text,
              disabled: isDisabled,
              element: 'found'
            });
            console.log('üîÑ Bouton suivant: ' + text + (isDisabled ? ' (d√©sactiv√©)' : ' (actif)'));
          }
          
          if (text.includes('Saison pr√©c√©dente') || text.includes('Pr√©c√©dente')) {
            seasonData.navigationButtons.push({
              type: 'prev', 
              text: text,
              disabled: isDisabled,
              element: 'found'
            });
            console.log('üîÑ Bouton pr√©c√©dent: ' + text + (isDisabled ? ' (d√©sactiv√©)' : ' (actif)'));
          }
        });
        
        // 3. Si on trouve un dropdown, essayer de cliquer pour voir les options
        if (seasonDropdown) {
          try {
            console.log('üîÑ Tentative d\\'ouverture du dropdown...');
            seasonDropdown.click();
            
            // Attendre que le dropdown s'ouvre
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Chercher les options du dropdown
            const dropdownOptions = document.querySelectorAll('[role="option"], [class*="dropdown"] [class*="option"], [class*="select"] option');
            dropdownOptions.forEach(option => {
              const text = option.textContent?.trim() || '';
              if (text.includes('Fire Force') || text.includes('Season') || text.includes('Saison') || text.match(/S[1-9]/)) {
                seasonData.availableSeasons.push({
                  text: text,
                  value: option.getAttribute('value') || '',
                  selected: option.hasAttribute('selected') || option.classList.contains('selected')
                });
                console.log('üé¨ Option saison: ' + text);
              }
            });
            
            // Refermer le dropdown
            seasonDropdown.click();
            
          } catch (e) {
            console.log('‚ö†Ô∏è Erreur ouverture dropdown: ' + e.message);
          }
        }
        
        return seasonData;
      `);
      
      console.log(`üîç Donn√©es saisons:`, seasonsFound);
      
      const allEpisodes: Episode[] = [];
      const seasonData = seasonsFound as any;
      
      // Strat√©gie 1: Utiliser le dropdown si disponible
      if (seasonData.dropdownFound && seasonData.availableSeasons.length > 0) {
        console.log(`üé¨ Navigation via dropdown: ${seasonData.availableSeasons.length} saisons disponibles`);
        
        for (let i = 0; i < Math.min(seasonData.availableSeasons.length, 3); i++) {
          const season = seasonData.availableSeasons[i];
          const seasonNumber = i + 1;
          
          try {
            console.log(`üé¨ S√©lection saison ${seasonNumber}: ${season.text}`);
            
            // Ouvrir le dropdown et s√©lectionner la saison
            const clicked = await driver.executeScript(`
              const dropdown = document.querySelector('div[aria="Saisons"]');
              if (dropdown) {
                dropdown.click();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const options = document.querySelectorAll('[role="option"], [class*="option"]');
                for (const option of options) {
                  const text = option.textContent?.trim() || '';
                  if (text.includes('${season.text.substring(0, 20)}')) {
                    console.log('üîÑ Clic option: ' + text);
                    option.click();
                    return true;
                  }
                }
              }
              return false;
            `);
            
            if (clicked) {
              await new Promise(resolve => setTimeout(resolve, 3000));
              await this.extractSeasonEpisodes(driver, animeId, seasonNumber, allEpisodes);
            }
            
          } catch (error) {
            console.log(`‚ö†Ô∏è Erreur saison ${seasonNumber}:`, (error as Error).message);
          }
        }
      } 
      // Strat√©gie 2: Utiliser les boutons suivant/pr√©c√©dent
      else if (seasonData.navigationButtons.length > 0) {
        console.log(`üîÑ Navigation via boutons suivant/pr√©c√©dent`);
        
        // Commencer par la saison actuelle
        await this.extractSeasonEpisodes(driver, animeId, 1, allEpisodes);
        
        // Naviguer vers les saisons suivantes
        let seasonNumber = 2;
        let hasNextSeason = true;
        
        while (hasNextSeason && seasonNumber <= 3) {
          const nextButton = seasonData.navigationButtons.find((btn: any) => btn.type === 'next' && !btn.disabled);
          
          if (nextButton) {
            console.log(`üé¨ Navigation vers saison ${seasonNumber} via bouton suivant`);
            
            const clicked = await driver.executeScript(`
              const buttons = document.querySelectorAll('div.cta-wrapper');
              let foundButton = false;
              const targetSeason = arguments[0];
              
              for (const btn of buttons) {
                const text = btn.textContent?.trim() || '';
                if (text.includes('Saison suivante') || text.includes('Suivante')) {
                  foundButton = true;
                  if (!btn.classList.contains('state-disabled')) {
                    console.log('üîÑ Clic bouton suivant pour saison ' + targetSeason);
                    console.log('üîÑ Bouton texte:', text);
                    console.log('üîÑ Bouton classes:', btn.className);
                    
                    // Scroll vers le bouton et forcer le focus
                    btn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Essayer plusieurs m√©thodes de clic
                    try {
                      btn.focus();
                      btn.click();
                      console.log('‚úÖ Clic normal r√©ussi');
                    } catch (e) {
                      console.log('‚ö†Ô∏è Clic normal √©chou√©, tentative clic forc√©...');
                      try {
                        btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
                        console.log('‚úÖ Clic forc√© r√©ussi');
                      } catch (e2) {
                        console.log('‚ùå Tous les clics √©chou√©s:', e2.message);
                        return false;
                      }
                    }
                    
                    return true;
                  } else {
                    console.log('‚ùå Bouton suivant d√©sactiv√©');
                  }
                }
              }
              
              if (!foundButton) {
                console.log('‚ùå Aucun bouton "Saison suivante" trouv√©');
              }
              
              return false;
            `, seasonNumber);
            
            if (clicked) {
              await new Promise(resolve => setTimeout(resolve, 4000));
              
              // V√©rifier si on a bien chang√© de saison en examinant les √©pisodes
              const seasonChanged = await driver.executeScript(`
                // Compter les √©pisodes visibles pour d√©tecter le changement
                const episodeLinks = document.querySelectorAll('a[href*="/watch/"]');
                console.log('üì∫ Nombre √©pisodes visibles apr√®s navigation:', episodeLinks.length);
                
                // Examiner les titres d'√©pisodes pour d√©tecter la saison actuelle
                const episodeTitles = [];
                const seasonEpisodes = { s1: 0, s2: 0, s3: 0 };
                
                for (let i = 0; i < Math.min(10, episodeLinks.length); i++) {
                  const title = episodeLinks[i].textContent?.trim() || '';
                  const href = episodeLinks[i].href || '';
                  episodeTitles.push(title);
                  
                  // Compter par saison
                  if (title.includes('S1') || title.includes('Season 1')) seasonEpisodes.s1++;
                  if (title.includes('S2') || title.includes('Season 2')) seasonEpisodes.s2++;
                  if (title.includes('S3') || title.includes('Season 3')) seasonEpisodes.s3++;
                  
                  if (i < 5) {
                    console.log('üì∫ Episode ' + (i+1) + ':', title);
                  }
                }
                
                // V√©rifier l'√©tat des boutons de navigation
                const buttons = document.querySelectorAll('div.cta-wrapper');
                let prevEnabled = false, nextEnabled = false;
                
                buttons.forEach(btn => {
                  const text = btn.textContent?.trim() || '';
                  const disabled = btn.classList.contains('state-disabled');
                  
                  if (text.includes('pr√©c√©dent') || text.includes('Pr√©c√©dent')) {
                    prevEnabled = !disabled;
                  }
                  if (text.includes('suivant') || text.includes('Suivant')) {
                    nextEnabled = !disabled;
                  }
                });
                
                console.log('üîç Episodes par saison - S1:', seasonEpisodes.s1, 'S2:', seasonEpisodes.s2, 'S3:', seasonEpisodes.s3);
                console.log('üîç Boutons navigation - Pr√©c√©dent:', prevEnabled ? 'actif' : 'inactif', 'Suivant:', nextEnabled ? 'actif' : 'inactif');
                
                // Si on a des √©pisodes S2 ou S3, ou si le bouton pr√©c√©dent est maintenant actif, on a chang√© de saison
                const hasS2Episodes = seasonEpisodes.s2 > 0;
                const hasS3Episodes = seasonEpisodes.s3 > 0;
                const previousButtonNowActive = prevEnabled; // Si pr√©c√©dent actif, on n'est plus en S1
                
                const currentSeason = hasS3Episodes ? 3 : (hasS2Episodes ? 2 : 1);
                console.log('üé¨ Saison d√©tect√©e:', currentSeason);
                
                return {
                  seasonChanged: hasS2Episodes || hasS3Episodes || previousButtonNowActive,
                  detectedSeason: currentSeason,
                  hasS2: hasS2Episodes,
                  hasS3: hasS3Episodes,
                  prevButtonActive: prevEnabled
                };
              `);
              
              if (seasonChanged && (seasonChanged as any).seasonChanged) {
                const result = seasonChanged as any;
                console.log(`‚úÖ Navigation vers saison ${seasonNumber} r√©ussie (d√©tect√©e: S${result.detectedSeason})`);
                await this.extractSeasonEpisodes(driver, animeId, result.detectedSeason, allEpisodes);
                seasonNumber++;
              } else {
                console.log(`‚ùå √âchec navigation vers saison ${seasonNumber} - aucun changement d√©tect√©`);
                hasNextSeason = false;
              }
            } else {
              hasNextSeason = false;
            }
          } else {
            hasNextSeason = false;
          }
        }
      } 
      // Fallback: extraction saison unique
      else {
        console.log('üì∫ Aucun s√©lecteur multi-saisons trouv√©, extraction saison unique...');
        await this.extractSeasonEpisodes(driver, animeId, 1, allEpisodes);
      }
      
      console.log(`üî• Fire Force Total: ${allEpisodes.length} √©pisodes valides`);
      
      return { success: true, data: allEpisodes };
      
    } catch (error) {
      console.log('‚ùå Erreur Fire Force multi-saisons:', (error as Error).message);
      return { 
        success: false, 
        error: `Erreur Fire Force: ${(error as Error).message}` 
      };
    }
  }

  /**
   * Helper method to extract episodes from current season
   */
  private async extractSeasonEpisodes(driver: any, animeId: string, seasonNumber: number, allEpisodes: Episode[]): Promise<void> {
    try {
      console.log(`üì∫ Extraction √©pisodes saison ${seasonNumber}...`);
      
      // Scroll pour charger tous les √©pisodes
      await driver.executeScript(`
        for(let i = 0; i < 5; i++) {
          window.scrollTo(0, document.body.scrollHeight);
          await new Promise(resolve => setTimeout(resolve, 800));
        }
        window.scrollTo(0, 0);
      `);
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      const seasonEpisodes = await this.extractAllEpisodesSimple(animeId);
      
      // Valider que ce sont bien des √©pisodes Fire Force
      const validEpisodes = seasonEpisodes.filter(ep => {
        const title = ep.title.toLowerCase();
        return !title.includes('goblin') && !title.includes('slayer') && 
               !title.includes('eris') && !title.includes('overlord');
      });
      
      // Corriger le num√©ro de saison et √©viter les doublons
      const correctedEpisodes = validEpisodes.map(ep => ({
        ...ep,
        seasonNumber: seasonNumber,
        id: `${animeId}-s${seasonNumber}ep${ep.episodeNumber}`
      }));
      
      // √âviter les doublons d'URLs d√©j√† pr√©sentes
      const newEpisodes = correctedEpisodes.filter(newEp => 
        !allEpisodes.some(existingEp => existingEp.url === newEp.url)
      );
      
      if (newEpisodes.length > 0) {
        console.log(`‚úÖ Saison ${seasonNumber}: ${newEpisodes.length} nouveaux √©pisodes Fire Force extraits`);
        allEpisodes.push(...newEpisodes);
      } else {
        console.log(`‚ö†Ô∏è Saison ${seasonNumber}: Aucun nouvel √©pisode trouv√© (${correctedEpisodes.length} doublons filtr√©s)`);
      }
      
    } catch (error) {
      console.log(`‚ö†Ô∏è Erreur extraction saison ${seasonNumber}:`, (error as Error).message);
    }
  }

  /**
   * Extraction d'√©pisodes - Version simple qui fonctionne, adapt√©e de l'ancienne m√©thode
   */
  private async extractEpisodesEnhanced(animeId: string, animeSlug?: string): Promise<Episode[]> {
    console.log('üì∫ Extraction √©pisodes - m√©thode qui fonctionnait...');
    
    const driver = await this.browserManager.getDriver();
    
    // Scroll pour r√©v√©ler tous les √©pisodes (m√©thode qui marchait avant)
    await driver.executeScript('window.scrollTo(0, document.body.scrollHeight);');
    await new Promise(resolve => setTimeout(resolve, 3000));
    await driver.executeScript('window.scrollTo(0, 0);');
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Utiliser le s√©lecteur simple qui trouvait 74 √©pisodes
    console.log('üîç Recherche des √©pisodes et saisons...');
    
    // D'abord compter combien d'√©pisodes sont disponibles
    const episodeCount = await driver.executeScript(`
      const links = document.querySelectorAll('a[href*="/watch/"]');
      console.log('üéØ ' + links.length + ' √©pisodes trouv√©s avec: a[href*="/watch/"]');
      
      // Debug: montrer quelques URLs pour comprendre pourquoi 31 ne sont pas extraits
      console.log('üîç Debug: quelques URLs trouv√©es:');
      for(let i = 0; i < Math.min(10, links.length); i++) {
        const link = links[i];
        const href = link.href;
        const text = link.textContent?.trim() || 'NO_TEXT';
        console.log('  ' + (i+1) + '. ' + href + ' -> "' + text.substring(0, 30) + '"');
      }
      
      return links.length;
    `);
    
    console.log(`üéØ ${episodeCount} √©pisodes trouv√©s avec: a[href*="/watch/"]`);
    
    // Extraire directement tous les √©pisodes avec m√©tadonn√©es am√©lior√©es
    return await this.extractAllEpisodesSimple(animeId);
  }

  /**
   * D√©tection et navigation vers toutes les saisons disponibles
   */
  private async detectAndNavigateSeasons(driver: any): Promise<void> {
    try {
      console.log('üîç D√©tection des saisons disponibles...');
      
      // Attendre un peu pour que la page se charge
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Chercher les boutons/s√©lecteurs de saisons
      const seasonSelectors = [
        '[role="option"]', // S√©lecteur g√©n√©rique d'options
        'button[aria-label*="Season"]',
        'button[aria-label*="Saison"]',
        '[class*="season"]',
        '[data-testid*="season"]'
      ];
      
      for (const selector of seasonSelectors) {
        try {
          const seasonElements = await driver.findElements(By.css(selector));
          
          if (seasonElements.length > 1) {
            console.log(`üé¨ ${seasonElements.length} saisons d√©tect√©es avec ${selector}`);
            
            // Cliquer sur chaque saison pour charger ses √©pisodes
            for (let i = 0; i < Math.min(seasonElements.length, 3); i++) {
              try {
                const seasonEl = seasonElements[i];
                const text = await seasonEl.getText();
                
                if (text && (text.includes('Season') || text.includes('Saison') || text.match(/S\d+/))) {
                  console.log(`  üì∫ Chargement saison: ${text.substring(0, 30)}...`);
                  
                  // Scroll vers l'√©l√©ment et cliquer rapidement
                  await driver.executeScript('arguments[0].scrollIntoView(true);', seasonEl);
                  await new Promise(resolve => setTimeout(resolve, 200));
                  
                  await driver.executeScript('arguments[0].click();', seasonEl);
                  await new Promise(resolve => setTimeout(resolve, 1500));
                  
                  // Scroll rapide pour charger les √©pisodes
                  await driver.executeScript(`
                    window.scrollTo(0, document.body.scrollHeight);
                    setTimeout(() => window.scrollTo(0, 0), 500);
                  `);
                  await new Promise(resolve => setTimeout(resolve, 800));
                }
              } catch (error) {
                console.log(`    ‚ö†Ô∏è Erreur saison ${i + 1}:`, (error as Error).message);
              }
            }
            
            return; // Arr√™ter apr√®s avoir trouv√© des saisons
          }
        } catch (error) {
          // Continuer avec le prochain s√©lecteur
        }
      }
      
      console.log('üì∫ Aucune saison multiple d√©tect√©e, utilisation saison unique');
      
    } catch (error) {
      console.log('‚ö†Ô∏è Erreur d√©tection saisons:', (error as Error).message);
    }
  }

  /**
   * Tentative simplifi√©e pour charger plus d'√©pisodes via scroll et navigation
   */
  private async attemptMultiSeasonLoad(driver: any): Promise<void> {
    try {
      console.log('üîÑ Tentative de chargement multi-saisons...');
      
      // Scroll agressif et recherche de boutons "Voir plus"
      let loadedMore = true;
      let attempts = 0;
      
      while (loadedMore && attempts < 3) {
        loadedMore = await driver.executeScript(`
          const initialCount = document.querySelectorAll('a[href*="/watch/"]').length;
          console.log('üîç Episode count before loading: ' + initialCount);
          
          // Scroll vers le bas en plusieurs √©tapes
          for(let i = 0; i < 8; i++) {
            window.scrollTo(0, document.body.scrollHeight);
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
          
          // Chercher tous les types de boutons "voir plus"
          const moreSelectors = [
            'button:contains("VOIR PLUS")',
            'button:contains("Load more")', 
            'button:contains("Show more")',
            '[class*="more"]',
            '[class*="load"]',
            '[aria-label*="more"]',
            '[aria-label*="plus"]'
          ];
          
          let clickedSomething = false;
          
          // Chercher par texte
          const allButtons = document.querySelectorAll('button, [role="button"], [class*="button"]');
          allButtons.forEach(btn => {
            const text = btn.textContent?.trim() || '';
            if (text.includes('VOIR PLUS') || 
                text.includes('Load more') || 
                text.includes('Show more') ||
                text.includes('more episodes') ||
                text.includes('plus')) {
              try {
                console.log('üîÑ Clique sur: ' + text);
                btn.scrollIntoView();
                btn.click();
                clickedSomething = true;
              } catch(e) {
                console.log('Erreur clic: ' + e.message);
              }
            }
          });
          
          // Attendre un peu apr√®s les clics
          if (clickedSomething) {
            await new Promise(resolve => setTimeout(resolve, 3000));
          }
          
          // Scroll final
          window.scrollTo(0, document.body.scrollHeight);
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          const finalCount = document.querySelectorAll('a[href*="/watch/"]').length;
          console.log('üîç Episode count after loading: ' + finalCount);
          
          return finalCount > initialCount;
        `);
        
        attempts++;
        console.log(`üîÑ Tentative ${attempts}: ${loadedMore ? 'Plus d\'√©pisodes charg√©s' : 'Aucun nouvel √©pisode'}`);
        
        if (loadedMore) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Recherche et navigation multi-saisons am√©lior√©e
      console.log('üîç Recherche des saisons disponibles...');
      
      // D'abord, chercher les s√©lecteurs de saison
      const seasonInfo = await driver.executeScript(`
        const seasonElements = [];
        
        // Chercher diff√©rents types de s√©lecteurs de saison
        const selectors = [
          '[role="option"]',
          'button[aria-label*="Season"]',
          'button[aria-label*="Saison"]', 
          '[class*="season"]',
          'select option',
          '[data-testid*="season"]'
        ];
        
        for (const selector of selectors) {
          const elements = document.querySelectorAll(selector);
          elements.forEach(el => {
            const text = el.textContent?.trim() || el.getAttribute('aria-label') || '';
            if (text && (text.includes('Season') || text.includes('Saison') || text.match(/S[1-9]/))) {
              seasonElements.push({
                text: text.substring(0, 50),
                selector: selector,
                position: el.getBoundingClientRect()
              });
            }
          });
        }
        
        return {
          seasons: seasonElements,
          currentPage: document.title,
          url: window.location.href
        };
      `);
      
      console.log(`üé¨ ${(seasonInfo as any).seasons.length} saisons d√©tect√©es:`, (seasonInfo as any).seasons.map((s: any) => s.text));
      
      // Essayer de naviguer vers chaque saison trouv√©e
      for (const season of (seasonInfo as any).seasons.slice(0, 3)) {
        try {
          console.log(`üîÑ Navigation vers: ${season.text}`);
          
          const clicked = await driver.executeScript(`
            const elements = document.querySelectorAll('${season.selector}');
            for (const el of elements) {
              const text = el.textContent?.trim() || el.getAttribute('aria-label') || '';
              if (text.includes('${season.text.split(' ')[0]}')) {
                el.scrollIntoView({behavior: 'smooth', block: 'center'});
                setTimeout(() => el.click(), 500);
                return true;
              }
            }
            return false;
          `);
          
          if (clicked) {
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Scroll pour charger les nouveaux √©pisodes
            await driver.executeScript(`
              window.scrollTo(0, document.body.scrollHeight);
              setTimeout(() => window.scrollTo(0, 0), 1000);
            `);
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
          
        } catch (error) {
          console.log(`‚ö†Ô∏è Erreur navigation saison "${season.text}":`, (error as Error).message);
        }
      }
      
    } catch (error) {
      console.log('‚ö†Ô∏è Erreur chargement multi-saisons:', (error as Error).message);
    }
  }

  /**
   * Extraction simple de tous les √©pisodes - version qui marchait avant + m√©tadonn√©es am√©lior√©es
   */
  private async extractAllEpisodesSimple(animeId: string): Promise<Episode[]> {
    const driver = await this.browserManager.getDriver();
    
    // Essayer de charger toutes les saisons en scrollant et navigant
    await this.attemptMultiSeasonLoad(driver);
    
    const debugInfo = await driver.executeScript(`
      // Debug initial
      const allLinks = document.querySelectorAll('a[href*="/watch/"]');
      const debugData = {
        totalLinks: allLinks.length,
        firstFewUrls: []
      };
      
      for(let i = 0; i < Math.min(15, allLinks.length); i++) {
        const link = allLinks[i];
        debugData.firstFewUrls.push({
          href: link.href,
          text: link.textContent?.trim()?.substring(0, 40) || 'NO_TEXT',
          isMusic: link.href.includes('/musicvideo/'),
          isMovie: link.href.includes('/movie/'),
          isConcert: link.href.includes('/concert/')
        });
      }
      
      return debugData;
    `);

    const debug = debugInfo as any;
    console.log('üîç Debug URLs trouv√©es:', debug.totalLinks, 'total');
    debug.firstFewUrls.forEach((item: any, i: number) => {
      console.log(`  ${i+1}. ${item.href} -> "${item.text}" (music:${item.isMusic}, movie:${item.isMovie}, concert:${item.isConcert})`);
    });

    return await driver.executeScript(`
      const episodeList = [];
      
      console.log('üîç Extraction simple - m√©thode qui fonctionnait');
      
      // Utiliser le s√©lecteur simple qui trouvait tous les √©pisodes
      const allLinks = document.querySelectorAll('a[href*="/watch/"]');
      console.log('üîç Total √©l√©ments potentiels: ' + allLinks.length);
      
      const processedUrls = new Set();
      const processedTitles = new Set(); // √âviter les doublons de titres
      
      // Regrouper d'abord les liens par URL unique
      const episodeMap = new Map();
      
      allLinks.forEach((linkEl, index) => {
        if (!(linkEl instanceof HTMLAnchorElement)) return;
        
        const href = linkEl.href;
        if (!href || !href.includes('/watch/')) return;
        
        // Filtrer les URLs non-√©pisodes (music videos, etc.)
        if (href.includes('/musicvideo/') || href.includes('/movie/') || href.includes('/concert/')) {
          return;
        }
        
        const text = linkEl.textContent?.trim() || '';
        
        // Prioriser les liens avec de vrais titres d'√©pisodes
        const hasGoodTitle = text.length > 10 && 
                           (text.includes('E') || text.includes('-') || text.includes('Ep')) && 
                           !text.match(/^\\d+m$/) && 
                           !text.match(/^\\d+$/) &&
                           !text.toLowerCase().includes('lecture') &&
                           text !== 'NO_TEXT';
        
        const hasBetterTitle = hasGoodTitle && text.length > 15;
        
        // Remplacer seulement si on a un meilleur titre ou si pas d'entr√©e existante
        if (!episodeMap.has(href) || 
            (hasBetterTitle && !episodeMap.get(href)?.hasGoodTitle) ||
            (hasGoodTitle && episodeMap.get(href)?.text === 'NO_TEXT')) {
          episodeMap.set(href, {
            linkEl: linkEl,
            text: text,
            href: href,
            index: index,
            hasGoodTitle: hasGoodTitle,
            titleQuality: hasBetterTitle ? 3 : (hasGoodTitle ? 2 : 1)
          });
        }
      });
      
      console.log('üîç Episodes uniques d√©tect√©s: ' + episodeMap.size);
      
      // Maintenant traiter chaque √©pisode unique
      episodeMap.forEach((episode) => {
        const linkEl = episode.linkEl;
        const href = episode.href;
        
        // Extraction am√©lior√©e du titre depuis le conteneur parent
        let title = '';
        let thumbnail = '';
        let duration = '';
        
        // Chercher dans le conteneur parent pour les m√©tadonn√©es
        const container = linkEl.closest('[class*="episode"], [class*="card"], [data-testid*="episode"]') || linkEl;
        
        // Utiliser le texte du lien si c'est un bon titre, sinon chercher ailleurs
        if (episode.hasGoodTitle && episode.text.length > 5) {
          title = episode.text;
        } else {
          // Extraction du titre avec priorit√© sur les √©l√©ments d√©di√©s
          const titleSources = [
            container.querySelector('[class*="title"]:not([class*="series"]):not([class*="show"])')?.textContent?.trim(),
            container.querySelector('h3, h4, h5')?.textContent?.trim(),
            linkEl.getAttribute('aria-label'),
            linkEl.getAttribute('title'),
            container.getAttribute('aria-label'),
            linkEl.textContent?.trim()
          ];
          
          title = titleSources.find(t => t && t.length > 3 && 
            !t.match(/^\\d+m$/) && 
            !t.includes('LECTURE')
          ) || '';
        }
        
        // Si toujours pas de titre, construire depuis l'URL
        if (!title) {
          const urlMatch = href.match(/\\/watch\\/[^\\/]+\\/([^\\/?]+)/);
          if (urlMatch) {
            title = urlMatch[1].replace(/-/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());
          }
        }
        
        // Extraction du num√©ro d'√©pisode am√©lior√©e
        let episodeNumber = episodeList.length + 1;
        const numberSources = [
          title,
          href,
          container.textContent || '',
          linkEl.textContent || ''
        ];
        
        for (const source of numberSources) {
          const matches = [
            source.match(/(?:Episode|Ep|E)\\s*(\\d+)/i),
            source.match(/episode[-_]?(\\d+)/i),
            source.match(/ep(\\d+)/i),
            source.match(/S\\d+\\s*E(\\d+)/i),
            // Pattern pour extraire le num√©ro depuis l'URL Crunchyroll
            source.match(/\\/watch\\/[A-Z0-9]+\\/(.*?)(?:\\?|$)/i)?.input?.match(/episode-(\\d+)/i),
            source.match(/\\/(\\d+)(?:\\/|$|\\?|-)/)
          ];
          
          for (const match of matches) {
            if (match && match[1]) {
              const num = parseInt(match[1], 10);
              if (num > 0 && num < 1000) { // Valeurs raisonnables
                episodeNumber = num;
                break;
              }
            }
          }
          if (episodeNumber !== episodeList.length + 1) break;
        }
        
        // Si pas de num√©ro trouv√©, utiliser l'ordre + 1
        if (episodeNumber === episodeList.length + 1 || episodeNumber < 1) {
          episodeNumber = episodeList.length + 1;
        }
        
        // D√©tection de la saison am√©lior√©e depuis le titre, URL et contexte DOM
        let seasonNumber = 1;
        const seasonSources = [
          title, 
          href, 
          container.textContent || '',
          // Chercher dans les √©l√©ments parents pour des indices de saison
          container.closest('[class*="season"]')?.textContent || '',
          document.querySelector('[class*="selected"] [class*="season"]')?.textContent || '',
          document.querySelector('[aria-selected="true"]')?.textContent || ''
        ];
        
        for (const source of seasonSources) {
          if (!source) continue;
          
          const seasonMatches = [
            source.match(/S(\\d+)/i),
            source.match(/Season\\s*(\\d+)/i),
            source.match(/Saison\\s*(\\d+)/i),
            // Patterns pour URLs Crunchyroll avec saison
            source.match(/season-(\\d+)/i),
            source.match(/s(\\d+)e\\d+/i)
          ];
          
          for (const match of seasonMatches) {
            if (match && match[1]) {
              const num = parseInt(match[1]);
              if (num > 0 && num <= 20) { // Saisons raisonnables
                seasonNumber = num;
                break;
              }
            }
          }
          if (seasonNumber !== 1) break;
        }
        
        // Description supprim√©e car non disponible sur Crunchyroll
        
        // Extraction de la dur√©e am√©lior√©e - chercher "23m" depuis les anciens logs
        const durationSources = [
          container.querySelector('[class*="duration"], .runtime')?.textContent?.trim(),
          container.textContent?.match(/\\d+m/)?.[0],
          linkEl.textContent?.match(/\\d+m/)?.[0],
          // Chercher dans les √©l√©ments adjacents du episodeMap original
          episode.text?.match(/\\d+m/)?.[0],
          // Chercher dans tous les √©l√©ments de la ligne d'√©pisode
          container.parentElement?.textContent?.match(/\\d+\\s*m/)?.[0],
          '23m' // Dur√©e par d√©faut pour Fire Force (vu dans les anciens tests)
        ];
        
        for (const d of durationSources) {
          if (d && d.match(/\\d+\\s*m/)) {
            duration = d.replace(/\\s+/g, '');
            break;
          }
        }
        
        // Extraction du thumbnail am√©lior√©e - chercher dans toute la zone de l'√©pisode
        const episodeContainer = linkEl.closest('[class*="episode"], [class*="item"], [class*="card"], [role="listitem"], [class*="playable"]') || 
                                container.parentElement || container;
        
        // Recherche plus agressive des images - chercher dans tous les conteneurs parents/siblings
        const searchContainers = [
          episodeContainer,
          container,
          linkEl.parentElement,
          linkEl.closest('article'),
          linkEl.closest('[class*="wrapper"]'),
          linkEl.closest('[class*="grid"]'),
          // Chercher aussi dans les fr√®res et s≈ìurs
          ...Array.from(episodeContainer.children || []),
          ...Array.from(episodeContainer.parentElement?.children || [])
        ].filter(Boolean);
        
        for (const searchContainer of searchContainers) {
          const images = searchContainer.querySelectorAll('img');
          
          for (const img of images) {
            if (img instanceof HTMLImageElement) {
              const srcSources = [
                img.src,
                img.getAttribute('data-src'),
                img.getAttribute('data-lazy'),
                img.getAttribute('data-original'),
                img.getAttribute('data-background'),
                img.getAttribute('data-bg'),
                // Chercher dans srcset pour les images responsive
                img.getAttribute('srcset')?.split(',').map(s => s.trim().split(' ')[0]).find(url => url.includes('http')),
                // Chercher dans les attributs style pour les background-image
                img.getAttribute('style')?.match(/background-image\\s*:\\s*url\\(['"]?([^'"\\)]+)['"]?\\)/)?.[1]
              ].filter(Boolean);
              
              for (const src of srcSources) {
                if (src && src.includes('http') && !src.includes('data:image') && !src.includes('placeholder')) {
                  // Filtres am√©lior√©s pour les images Crunchyroll
                  const isValidThumbnail = (
                    src.includes('crunchyroll') || 
                    src.includes('cdn') || 
                    src.includes('img') ||
                    src.includes('thumb') ||
                    src.includes('episode') ||
                    // Formats d'image communs
                    /\\.(jpg|jpeg|png|webp)/.test(src.toLowerCase())
                  ) && (
                    // Exclure les ic√¥nes et petites images
                    !src.includes('icon') &&
                    !src.includes('logo') &&
                    !src.includes('avatar') &&
                    !src.match(/\\d+x\\d+/) || src.match(/(\\d+)x(\\d+)/) && parseInt(RegExp.$1) >= 200
                  );
                  
                  if (isValidThumbnail) {
                    thumbnail = src.trim();
                    console.log('üñºÔ∏è Thumbnail trouv√©:', thumbnail.substring(0, 60));
                    break;
                  }
                }
              }
              if (thumbnail) break;
            }
          }
          if (thumbnail) break;
        }
        
        // Titre final si toujours vide
        if (!title || title.length < 3) {
          title = 'Episode ' + episodeNumber;
        }
        
        // Cr√©er une cl√© unique pour √©viter les vrais doublons bas√©e sur l'URL principalement
        const episodeKey = href; // Utiliser l'URL comme cl√© principale
        
        // √âviter seulement les doublons d'URL exacte (d√©j√† g√©r√© plus haut)
        // if (processedTitles.has(episodeKey)) {
        //   console.log('üîÑ Doublon √©vit√©: ' + title);
        //   return;
        // }
        // processedTitles.add(episodeKey);
        
        episodeList.push({
          id: href.split('/watch/')[1]?.split('/')[0] || arguments[0] + '-s' + seasonNumber + 'ep' + episodeNumber,
          animeId: arguments[0],
          title: title,
          episodeNumber: episodeNumber,
          seasonNumber: seasonNumber,
          thumbnail: thumbnail || undefined,
          duration: duration || undefined,
          url: href
        });
        
        if (episodeList.length <= 20 || episodeList.length % 5 === 0) {
          console.log('  üì∫ ' + (episodeList.length) + '. S' + String(seasonNumber).padStart(2, '0') + 'E' + String(episodeNumber).padStart(2, '0') + ' - ' + title.substring(0, 30));
        }
      });
      
      console.log('üé¨ Total √©pisodes extraits: ' + episodeList.length);
      
      return episodeList.sort((a, b) => {
        if (a.seasonNumber !== b.seasonNumber) {
          return a.seasonNumber - b.seasonNumber;
        }
        return a.episodeNumber - b.episodeNumber;
      });
    `, animeId);
  }

  /**
   * Extraction des √©pisodes depuis les APIs intercept√©es
   */
  private async extractEpisodesFromAPIs(animeId: string): Promise<Episode[]> {
    const episodes: Episode[] = [];
    
    // Chercher toutes les APIs d'√©pisodes pour cette s√©rie
    const episodeApis = Array.from(this.apiResponses.keys()).filter(url => 
      url.includes('/episodes') && (url.includes(animeId) || url.includes('/seasons/'))
    );
    
    console.log(`üîç ${episodeApis.length} API(s) d'√©pisodes trouv√©e(s)`);
    
    for (const apiUrl of episodeApis) {
      const apiData = this.apiResponses.get(apiUrl);
      if (apiData && apiData.data) {
        const items = apiData.data;
        console.log(`üì∫ API: ${items.length} √©pisodes dans ${apiUrl}`);
        
        for (const item of items) {
          if (item.type === 'episode' || item.episode_number) {
            const episode: Episode = {
              id: item.id || item.guid || `${animeId}-ep${item.episode_number}`,
              animeId: animeId,
              title: item.title || `Episode ${item.episode_number}`,
              episodeNumber: parseInt(item.episode_number) || episodes.length + 1,
              seasonNumber: parseInt(item.season_number) || 1,
              url: `${this.baseUrl}/watch/${item.id}/${item.slug_title || ''}`,
              thumbnail: this.extractThumbnailFromApiItem(item)
            };
            
            episodes.push(episode);
            console.log(`‚úÖ API Episode ${episode.episodeNumber}: "${episode.title}"`);
          }
        }
      }
    }
    
    return episodes;
  }



  /**
   * Extraction optimis√©e du thumbnail depuis les donn√©es API
   */
  private extractThumbnailFromApiItem(item: any): string {
    const sources = [
      item.images?.thumbnail?.[0]?.[0]?.source,
      item.images?.thumbnail?.[0]?.source,
      item.images?.poster_tall?.[0]?.source,
      item.thumbnail_image,
      item.poster_image,
      item.image
    ];
    
    return sources.find(source => source && source.includes('http')) || '';
  }

  async close(): Promise<void> {
    await this.browserManager.close();
  }
}